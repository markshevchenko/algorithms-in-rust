# 2.1. Это цифра?

<dl>
  <dt>Задача 2.1.1.</dt>
  <dd>
  Алина пишет программу, которая умеет распознавать числа в текстовых файлах, которые хранятся в кодировке ASCII.
  Ей нужна функция, которая умеет определять, является ли символ ASCII цифрой.
  Стандартная библиотека Rust работает с символами Unicode, поэтому Алине нужно написать свою функцию, работающую с символами ASCII.
  </dd>
</dl>

## ASCII и Unicode

Во-первых, давайте в общих чертах разберёмся, чем символы ASCII отличаются от Unicode.
Первое важное отличие заключается в том, что символы ASCII представляются и хранятся одинаково, в виде одного-единственного байта.
В Rust их тип совпадает с типом для хранения байтов, а именно `u8` (беззнаковое 8-мибитовое число).

Для представления символов используется префикс **b** — `b'A'` — это ASCII-символ латинская заглавная A.

В Unicode символ Ⓐ (латинская заглавная A в круге) имеет десятичный код 9398.
То, как она хранится в памяти и на диске, зависит от способа кодирования.
Код символов Unicode принято указывать в шестнадцатиричном виде с префиксом **U+**.
Ⓐ имеет код U+24B6, это способ представления символа.

Способ хранения может быть разным.
В Rust одиночный символ Unicode хранится в формате UTF-32, то есть в виде 32-хбитного числа.

В стандартной библиотеке Rust есть метод `is_ascii_digit()`, но он работает только с символами Unicode.
Если мы оперируем байтами, нам придётся переводить их в символы Unicode перед тем, как вызвать стандартный метод.

Чтобы не делать этого, давайте напишем свой метод проверки.

В таблице ASCII цифры расположены подряд в кодовых позициях с 48-й (это `'0'`) по 57-ю (это `'9'`).
Это сильно упрощает реализацию.

```rust
pub fn is_digit(c: u8) -> bool {
    c >= b'0' && c <= b'9'
}
```

Похожим образом напишем функции, распознающие *маленькие* и *большие* буквы английского.

```rust
pub fn is_lower(c: u8) -> bool {
    c >= b'a' && c <= b'z'
}

pub fn is_upper(c: u8) -> bool {
    c >= b'A' && c <= b'Z'
}
```

Функция, распознающая буквы вне зависимости от регистра (от того, большие они или маленькие) — уже сложнее.
Ей нужно проверять два несвязанных диапазона значений, поскольку в таблице ASCII между большими и маленькими буквами затесалось несколько символов.

Впрочем, мы можем воспользоваться тем, что уже написали функции `is_lower()` и `is_upper()` и свести задачу к их вызову.

```rust
pub fn is_letter(c: u8) -> bool {
    is_lower(c) || is_upper(c)
}
```

> [!TASK]
> А вдруг работает?

## Упражнения

<dl>
  <dt>Задача 2.1.2.</dt>
  <dd>
  Напишите функцию <code>is_control()</code>, которая распознаёт управляющие символы.
  К управляющим символом относятся символы с кодами от 0 до 31 включительно, а также символ с кодом 127.
  </dd>
</dl>
