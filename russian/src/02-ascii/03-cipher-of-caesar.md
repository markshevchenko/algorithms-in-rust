# 2.3. Шифр Цезаря

Говорят, что Цезарь придумал отсроумный способ шифрования, который позволял быстро кодировать и декодировать латинский текст.

Компьютеров во времена Цезаря не было, поэтому кодирование и декодирование осуществлялись в уме.

Этот метод шифрования симметричный, то есть для кодирования и декодирования используется один и тот же ключ.
Для шифра Цезаря ключ — это натуральное число, скажем, 5.

A B C D E F G H I J K L N M O P Q R S T U V W X Y Z

Для того, чтобы зашифровать букву, мы должны взять пятую букву справа от неё. Если мы долшли до конца алфавита, просто продолжаем считать с начала.

Пятая буква справа от A — это F, пятая буква справа от Q — это V, и пятая буква от X — C.

Таким образом, строка LOREM кодируется в строку QTWJR.

Декодировашие осуществляется похожим образом, только вместо пятой буквы справа ищем пятую букву слева, а, если доходим до начала алфавита, продолжаем считать с конца.

<dl>
  <dt>Задача 2.3.1.</dt>
  <dd>
  Настя реализует шифр Цезаря. Ей нужно написать фунукцию, которая шифрует один ASCII-символ. Функция получает на вход букву и ключ — положительное число типа <code>u8</code>.
  Функция шифрует большие и меленькие буквы независимо — строка <code>b"LOREM"</code> с ключом 5 превращается в <code>b"QTWJR"</code>, а <code>b"lorem"</code> — в <code>b"qtwjr"</code>.
  Помогите Насте реализовать шифрование.
  </dd>
</dl>

## Проектирование алгоритма

Тексты состоят из больших букв, маленьких букв и других символов, таких как пробелы и знаки препинания. Наша функция шифрования, судя по описанию, должна отдельно шифровать большие буквы и маленькие буквы, а все прочие символы оставлять неизменными.

У нас появляется три варианта, которые должны обрабаываться в программе.

```rust
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
    if is_lower(c) {
        // ...
    } else if is_upper(c) {
        // ...
    } else {
        c
    }
}
```

*Сдвиг* — это, фактически, прибавление ключа к коду символа. Символ `b'L'` имеет код 76. Если прибавить 5, получим 81, а это код символа `b'Q'`.

Для того, чтобы безопасно переходить границу алфавита, мы будем использовать *модульную арифметику*.
В арифметике по модулю $N$, значения могут находиться только в диапазоне от $0$ до $N - 1$. Если в процессе вычислений мы получаем число вне этого интервала, то используем в качестве результата *остаток от деления* числа на $N$.

В английском алфавите 26 букв. Для вычислений нам потребуется остаток от деления на 26, который может принимать значения от 0 до 25.

Пронумеруем буквы алфавита. A получит номер 0, B — номер 1, С — 2 и так далее вплоть до Z, которая получит номер 25.
Предположим, мы хотим вычислить пятую буквы справа от X. X имеет номер 23, прибавляем 5 и получаем 28.

Остаток от деления 28 на 26 даёт 2, и это номер символа C.

Чтобы реализовать этот алгоритм, нам надо перейти от кодов ASCII к нашей внутренней нумерации, выполнить преобразование, а затем преобразовать внутренний номер (от 0 до 25) обратно в код символа.

Первое преобразование мы сделаем, вычтя из кода буквы код первой буквы алфавита, а имеенно A.

```rust
c - b'A'
```

Затем мы должны прибвать ключ. Если мы вышли за правую границу (за букву Z), то должны применить модульную арифметику.

```rust
if c - b'A' + key > 25 {
  // ...
}
```

Но, оказывается, это слишком сложный код для данной операции. Если мы не вышли за правую границу, мы точно также можем использовать модульную арифметику (вычислять остаток), потому что если результат меньше модуля, то он останется тем же самым.

```rust
(c - b'A' + key) % 26
```

Мы получили внутренний номер буквы, то есть число от 0 до 25. Чтобы превратить его в код ASCII, нам надо снова прибавить к нему код символа A.

```rust
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
    if is_lower(c) {
        (c - b'a' + key) % 26 + b'a'
    } else if is_upper(c) {
        (c - b'A' + key) % 26 + b'A'
    } else {
        c
    }
}
```

## Работаем над стилем

Этот код довольно прозрачен.
Модульная арифметика встречается часто, поэтому программисты распознают её практически не лету.
Мы видим оператор `%` — остаток от деление, и понимаем, что речь идёт об арифметике по модулю 26.
Большинство из нас опознают 26 как *размер английского алфавита* или *количество букв в английском алфавите*.

Но эту идею можно выразить явно:

```rust
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
    const LETTER_COUNT: u8 = b'Z' - b'A' + 1;

    if is_lower(c) {
        (c - b'a' + key) % LETTER_COUNT + b'a'
    } else if is_upper(c) {
        (c - b'A' + key) % LETTER_COUNT + b'A'
    } else {
        c
    }
}
```

Возможно у вас возникает вопрос, почему количество букв, это код символа Z минут код символа A *плюс единица*.
Ответ заключается в том, что, если бы мы не прибавили единицу, мы получили бы известную ошибку, у которой даже есть название — *off-by-one error* или *ошибка неучтённой единицы*.

Она часто встречается в программах, даже не смотря на то, что считается одной из самых известных, то есть программисты должны были бы её опознавать предотвращать.

Так в чём же состоит ошибка неучтённой единицы?
Предположим, мы едем по трассе, где расположены километровые столбы.
Мы видим столб $173$, затем через некоторое время столб $205$, и хотим узнать, сколько километров мы проехали.
Правильный ответ $205-173$ или $32$ километра.

Затем мы хотим узнать, сколько столбов *между* столбами $173$ и $205$?
Интуитивно снова хочется ответить $32$, но на самом деле нет.

Сколько столбов между $173$ и $175$? Всего один — с номером $174$.
Это на единицу *меньше*, чем $175 - 173$.

Правильный ответ на вопрос «сколько столбов между $173$ и $205$» составляет $(205 - 173) - 1 = 31$.

Следующий вопрос: сколько всего столбов от столба $173$ до столба $205$?
Интуитивный ответ такой же, как и в прошлом случае: $32$.

Но сколько всего столбов от столба $173$ до столба $175$? Три — с номерами $173$, $174$ и $175$.
Это на единицу *больше*, чем $175 - 173$.

Правильный ответ на вопрос «сколько столбов от столба $173$ до столба $205$» составляет $(205 - 173) + 1 = 33$.

Программисты должны опознавать оба случая и прибавлять, либо вычитать единицу, когда надо.

Возвращаемся к английскому алфавиту. Наш вопрос звучит так: «сколько всего букв от буквы A до буквы Z»?
И, как мы только что выяснили, чтобы ответить на этот вопрос правильно, надо прибавить единицу к разнице `b'Z' - b'A'`.

## Работаем над ошибками

Что ж, код идеален за одним исключением. В качестве ключа мы можем получить достаточно большое число, например, 250.

Кодируя букву `b'Z'` мы сначала получим её номер — то есть 25, потом прибавим к ней ключ, получив 275, и затем найдём остаток от деления на 26 — то есть 15.

Но 275 больше, чем 255, а 255 — максимальное значение, которое можно хранить в переменной типа `u8`.
При вычислении мы получим ошибку переполнения, хотя, по сути, никакой ошибки нет.

Что можно сделать?
Вариант номер один: использовать в процессе вычислений числа типа `u16` или `u32`.
Вариант номер два: обратить внимание на природу задачи.

В нашем случае, поскольку мы используем модульную арифметику, актуальные значения ключа — от $0$ до $25$.
Почему?

Представим, ключ равен $2$. Имея букву в номером `n`, мы можем вычислит номер зашифрованной буквы по формуле `(n + 2) % 26`.

Если мы используем ключ $28$ (то есть $2 + 26$), номер зашифрованной буквы будет равен `(n + 28) % 26`.
Но, поскольку раница $28-2$ делится на $26$ без остатка, по правилам модульной арифметики, результат будет один и тот же. То же самое справделиво и для ключей $2 + 26 + 26$, $2 + 26 + 26 + 26$ и так далее.

Так что мы можем в начале функции «урезать» ключ, вычислив отстаток от его деления на 26.

```rust
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
    const LETTER_COUNT: u8 = b'Z' - b'A' + 1;
    let key = key % LETTER_COUNT;

    if is_lower(c) {
        (c - b'a' + key) % LETTER_COUNT + b'a'
    } else if is_upper(c) {
        (c - b'A' + key) % LETTER_COUNT + b'A'
    } else {
        c
    }
}
```
<dl>
  <dt>Задача 2.3.2.</dt>
  <dd>
  Реализуйте обратную функцию декодирования, которая получает на вход букву и ключ и возвращает декодированную большую или маленькую букву, или тот же самый символ, если это буква.
  </dd>
</dl>
