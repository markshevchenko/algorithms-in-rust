# 2.1. Буквы, цифры

<dl>
  <dt>Задача 2.1.1.</dt>
  <dd>
  Алина пишет программу, которая умеет распознавать числа в текстовых файлах, которые хранятся в кодировке ASCII.
  Ей нужна функция, которая умеет определять, является ли символ ASCII цифрой.
  Стандартная библиотека Rust работает с символами Unicode, поэтому Алине нужно написать свою функцию, работающую с символами ASCII.
  </dd>
</dl>

## ASCII и Unicode

Во-первых, давайте в общих чертах разберёмся, чем символы ASCII отличаются от Unicode.
Первое важное отличие заключается в том, что символы ASCII представляются и хранятся одинаково, в виде одного-единственного байта.
В Rust их тип совпадает с типом для хранения байтов, а именно `u8` (беззнаковое 8-мибитовое число).

Работая с ASCII символами, мы можем указывать их код, например, 65, или сам симфол с префиксом **b**.
Коду 65 соответствует символ `b'A'`.

В Unicode символ Ⓐ (латинская заглавная A в круге) имеет десятичный код 9398.
То, как она хранится в памяти и на диске, зависит от способа кодирования.
Код символов Unicode принято указывать в шестнадцатиричном виде с префиксом **U+**.
Ⓐ имеет код U+24B6 — это способ представления символа.

Способ хранения может быть разным.
В Rust одиночный символ Unicode хранится в формате UTF-32, то есть в виде 32-хбитного числа.

В стандартной библиотеке Rust есть метод `is_ascii_digit()`, но он работает только с символами Unicode.
Если мы оперируем байтами, нам придётся переводить их в символы Unicode перед тем, как вызвать стандартный метод.

Чтобы не делать этого, давайте напишем свой метод проверки.

В таблице ASCII цифры расположены подряд в кодовых позициях с 48-й (это `'0'`) по 57-ю (это `'9'`).
Это сильно упрощает реализацию.

```rust
pub fn is_digit(c: u8) -> bool {
    c >= 48 && c <= 57
}
```

Такой код сложно понимать, поскольку для этого надо знать (и помнить), что означают коды 48 и 57.
В Rust мы можем переписать его следующим образом.

```rust
pub fn is_digit(c: u8) -> bool {
    c >= b'0' && c <= b'9'
}
```

Похожим образом напишем функции, распознающие *маленькие* и *большие* буквы английского.

```rust
pub fn is_lower(c: u8) -> bool {
    c >= b'a' && c <= b'z'
}

pub fn is_upper(c: u8) -> bool {
    c >= b'A' && c <= b'Z'
}
```

Функция, распознающая буквы вне зависимости от регистра (от того, большие они или маленькие) — уже сложнее.
Ей нужно проверять два несвязанных диапазона значений, поскольку в таблице ASCII между большими и маленькими буквами затесалось несколько символов.

Впрочем, мы можем воспользоваться тем, что уже написали функции `is_lower()` и `is_upper()` и свести задачу к их вызову.

```rust
pub fn is_letter(c: u8) -> bool {
    is_lower(c) || is_upper(c)
}
```

## Меняем регистр

Английские буквы в таблице ASCII, что большие, что маленькие, расположены в алфавитном порядке без разрывов.
Это решение — очень логичное — упрощает большое количество практических задач.

Например, чтобы сортировать строки в *лексикографическом порядке*, достаточно обычного сравнения символов без дополнительных ухищрений.

Чтобы узнать код маленькой буквы `'x'` (120), надо прибавить 32 к коду большой буквы `'X'` (88).
Приведение к большим или маленьким буквам — частая операция, которая позволяет сортировать строки в алфавитном порядке без учёта регистра.

Простейшая функция, которая приводит большие буквы к маленьким, выглядит так.

```rust
pub fn to_lower(c: u32) -> u32 {
    c + 32
}
```

Однако, она работает только с большими буквами. Если вы передадите ей цифру или маленькую букву, то получите мусор.
Чтобы функция работала правильно, надо проверять, что мы действительно имеем дело с большой буквой.

```rust
pub fn to_lower(c: u32) -> u32 {
    if is_upper(c) {
        c + 32
    } else {
        c
    }
}
```

Этот код работает уже правильно, но читается всё ещё плохо.
Из кода неясно назначение константы 32.
Сделаем его очевидным.

```rust
pub fn to_lower(c: u32) -> u32 {
    if is_upper(c) {
        c + (b'a' - b'A')
    } else {
        c
    }
}
```

Выражение `b'a' - b'A'` можно трактовать, как *расстояние* между маленькими и большими буквами в таблице ASCII.

## Упражнения

<dl>
  <dt>Задача 2.1.2.</dt>
  <dd>
  Напишите функцию <code>is_control()</code>, которая распознаёт управляющие символы.
  К управляющим символом относятся символы с кодами от 0 до 31 включительно, а также символ с кодом 127.
  </dd>
</dl>

<dl>
  <dt>Задача 2.1.3</dt>
  <dd>
  Напишите функцию <code>to_upper()</code>, которая приводит маленькие буквы к большим.
  </dd>
</dl>