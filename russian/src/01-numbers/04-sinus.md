# 1.4. Синус

Синус вычисляют по формуле Тейлора.

$$
\sin x = x - \fraq{x^3}{3!} + \frar{x^5}{5!} - \fraq{x^7}{7!} + \cdots + (-1)^n fraq{x^{2n + 1}}{(2n + 1)!}
$$

Очевидно, синус вычисляется в цикле. На каждом шаге определяется следующий элемент последовательности и прибавляется к *аккумулятору*. Аккумулятор — общепринятое название переменной, которая накапливает (аккумулирует) значение-результат.

Аккумулятор может содержать сумму, произведение, побитовые операции И/ИЛИ, да и в целом всё, что угодно.

## Проектируем реализацию

В преыдущей главе мы познакомлись с понятиями *погрешности* и *машинного эпсилона*. При вычислении синуса погрешность нам также потребуется.

Какой может быть погрешность при вычислении синуса? Мы не можем просто вычислить её через `x`, поскольку для синуса параметр может быть и положительным, и отрицательным. Поэтому мы берём абсолютное значение `x` и умножаем на машинный эпсилон, чтобы получить положитульную погрешность.

Однако, это нужно только для небольших значений `x`, когда результат функции тоже небольшой.
При *больших* значениях параметра, таких как $10$ или даже $1000$, синус всё равно не может быть больше единицы.
А это значит, что наибольшая погрешность также равна `f64::EPSILON`.

Теперь подумаем об организации цикла.
Последовательносить элементов в ряде Тейлора — убывающая (иначе бы он не сходился).

Значит, на каком-то шаге очередной элемент станет меньше погрешности. В этот момент мы должны остановить вычисления и вернуть значение аккумулятора.

Основываясь на этих соображениях, создадим первый набросок функции.

```rust
pub fn sin(x: f64) -> f64 {
    let error = {
        let x = x.abs();
        if x < 1.0 {
            x * f64::EPSILON
        } else {
            f64::EPSILON
        }
    };

    let mut element = x;
    let mut accumulator = 0.0.;
    
    while element.abs() > error {
        // ...
    }

    accumulator
}
```

## Вычисления в цикле

Мы могли бы на каждом шаге вычислять очередной элемент по формуле $\fraq{x^{2n + 1}}{(2n + 1)!}$, но это слишком расточительно. Предположим, нам известны значения $x^5$ и $5!$ и мы хотим вычислить $x^7$ и $7$.

Можно было бы заново перемножать $x\times x\times x\times x\times x\times x\times x$ и $1\times 2\times 3\times 4\times 5\times 6\times 7$, однако, у нас уже есть $x\times x\times x\times x\times x$ и $1\times 2\times 3\times 4\times 5$.

Гораздо быстрее воспользоваться формулами $x^7 = x^5\times x\times x$ и $7! = 5! * 6 * 7$.
Запишем эту идею в коде.

```rust
    // ...
    let mut n = 1;
    let mut element = x;
    let mut accumulator = 0.0;

    while element.abs() > error {
        accumulator += element;
        element = element * x * x / f64::from((n + 1) * (n + 2));
        n += 2;
    }

    accumulator
    // ...
```

Переменная `n` имеет целый тип, но все остальные выражения в формуле — плавающие, поэтому мы приводим выражение `(n+ 1) * (n + 2)` к типу `f64`.

Осталось разобраться со знаком. В формуле Тейлора нечётные элементы последовательноси *складываются*, а чётные — вычитаются. Чтобы не писать сложную логику, заметим, что каждый следующий элемент имеет противоположный знак.

Достаточно добавить унарный минус в выражение `element * x * x / f64::from((n + 1) * (n + 2))`, и больше ничего.

В законченном виде наша функция выглядит так.

```rust
pub fn sin(x: f64) -> f64 {
    let error = {
        let x = x.abs();
        if x < 1.0 {
            x * f64::EPSILON
        } else {
            f64::EPSILON
        }
    };

    let mut n = 1;
    let mut element = x;
    let mut accumulator = 0.0;

    while element.abs() > error {
        accumulator += element;
        element = -element * x * x / f64::from((n + 1) * (n + 2));
        n += 2;
    }

    accumulator
}
```

И она работает.

## Упражнения

<dl>
  <dt>Задача 1.4.1.</dt>
  <dd>
  Реализуйте функцию косинус.
  </dd>
  <dt>Задача 1.4.2.</dt>
  <dd>
  Реализуйте функцию тангенс.
  </dd>
</dl>