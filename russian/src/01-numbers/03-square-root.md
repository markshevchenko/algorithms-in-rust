# 1.3. Квадратный корень

В стандартной библиотеке любого языка есть функция вычисления квадратного корня.
Когда я не знал, как она устроена, она казалась мне *волшебной*.
Синус можно посчитать по формуле Тейлора (мы сделаем это в следующей главе).
Но квадратный корень обычно считают по-другому.
Как же люди его вычисляют?
Как работает функция `sqrt`?

## Начнём с практики

Конечно, вычисление квадратного корня имеет не только теоретическую ценность.
В компьютерных играх для построения кратчайшего пути используется алгоритм А*, которому нужно вычислять расстояние между точками «по прямой», без учёта препятствий.

Каждая точка задаётся двумя координами, и вычисление расстояния произвоидтся по теореме Пифагора.

$$
d = \sqrt {(x_2 - x_1)^2 + (y_2 - y_1)^2}
$$

<dl>
  <dt>Задача 1.3.1.</dt>
  <dd>
  Алексей пишет компьтерную игру.
  Ему надо реализовать алгоритм А*, а для этого надо научиться вычислять квадратный корень.
  К сожалению, игра запускается на микроконтроллере и ей недоступна стандартная библиотека Rust.
  Помогите Алексею написать функцию вычисления квадратного корня.
  </dd>
</dl>

## Проектирование функции

Квадратный корень вычисляется для неотрицательных чисел.
В стандартной библиотеке редко учитывают *комплексные числа*, и если параметр функции отрицательный, надо предусмотреть какое-нибудь разумное поведение.

Один из вариантов — возвращать `Option<f64>`. В случае, если мы не можем вычислить квадратный корень, мы просто возвращаем `None`. К сожалению, это усложняет наши формулы, потому что мы не можем складывать или делить числа разных типов — `f64` и `Option<f64>`.

Второй вариант — вызывать панику и останавливать программу. Для реального промышленного кода этот подход слишком кардинален.

Наконец, мы можем возвращать *особое значение*, которое будет означать отсутствие решения. К счастью, у типов с плавающей точкой есть константа `NaN` (Not a Number — Не Число), которая как раз и означает результат операции, которую невозможно выполнить.

Итак, наша функция `sqrt` будет принимать значение типа `f64` и возвращать значение типа `f64`, в частности, `f64::NAN`, если `x` меньше нуля.

```rust
pub fn sqrt(x: f64) -> f64 {
    if x < 0.0 {
        return f64::NAN;
    }

    // ...
}
```

Что дальше?

## Вавилонский метод

*Вавилонский метод* или *метод Герона* — простой и, вероятно, самый древний алгоритм вычисления квадратного корня.
Он основывается на том соображении, что если какое-то число $a, 0 < a <= x$ больше $\sqrt x$, то $x/a$ — меньше.
Обратное утверждение также верно: если $a < \sqrt x$, то $x/a > \sqrt x$.

Логично предположить, что среднее арифметическое этих чисел будет ближе к корню, чем $a$[^1].

Повторяя вычисления, мы будем всё точнее вычислять квадратный корень.
Это утверждение не кажется очевидным.
Его доказательство опирается на неравенство среднего арифметического и среднего геометрического.

$$
\sqrt {a b} <= \frac{a + b}{2}
$$

На каждом шаге среднее арифметическое всё ближе к корню и при этом всегда больше либо равно ему.

Алгоритм в таком виде не пригоден для практического применения, поскольку он никогда не заканчивается, всё точнее и точнее вычисляя корень.
Нам же важно остановиться, и как можно раньше.
Код вычисления корня должен быть быстрым.

Мы можем остановиться, когда достигнем нужной точности.

Получив очередное приближение $a$, вычислим $a^2 - x$.
Если результат достигает, например $0.00001$, останавливаемся и возвращаем $a$.

Напишем первую версию функции.

```rust
pub fn sqrt(x: f64) -> f64 {
    if x < 0.0 {
        return f64::NAN;
    }

    let error = 0.00001;
    let mut a = x / 2.0;

    while (a * a - x).abs() > error {
        a = (a + x / a) / 2.0;
    }

    a
}
```

## Погрешность абсолютная и относительная

В качестве первого приближения мы взяли половину аргумента.
Мы можем использовать любое число больше нуля, и половина аргумента ничем не хуже других вариантов.

Этот код справляется с вычислением квадратных корней для чисел вроде $2$, $20$ или $2000$.
Однако, он пасует перед маленькими числами, такими как $0.000002$.

Эта ошибка часто встречается в учебном коде.
В промышленном коде погрешность (переменная `error`) должна быть не *абсолютной*, а *относительной" величиной.

В общем случае она должна быть равна $0.00001 |x|$, но поскольку в нашем случае $x > 0$, мы можем избавиться от модуля и положить погрешность равной $0.00001 x$.

```rust
pub fn sqrt(x: f64) -> f64 {
    if x < 0.0 {
        return f64::NAN;
    }

    let error = x * 0.00001;
    let mut a = x / 2.0;

    while (a * a - x).abs() > error {
        a = (a + x / a) / 2.0;
    }

    a
}
```

При вычислении погрешности есть *вырожденный случай* при $x = 0$.
В этом случае переменная `error` также становится равной $0$.
Мы должны были бы как-то проверять этот случай в коде, но, к счастью, именно здесь нас защищает сама логика сравнения.
Цикл продолжается только если очередное приближение *больше* погрешности, а при $x = 0$ мы получаем сравнение $0 < 0$, результат которого *ложь*.
Иными словами, при $x = 0$ цикл не будет выполен ни разу.

## Минимальная погрешность

Эта версия работает гораздо лучше, но она всё ещё не идеальна.
Сейчас вычисляет вычисляет корень с точностью в пять значащих цифр (пятая может быть результатом округления).

Обратие внимание, что речь идёт не пяти цифрах после запятой, а о пяти значащих цифрах.
Пять цифр после запятой теряют смысл, когда мы говорим об очень больших или очень маленьких числах, таких как $123456789$ и $0.0000123456789$.

Число $123456789$ превращается в $123456789.00000$.
Пять знаков после запятой для него — это чрезмерная точность.
В то же время $0.0000123456789$ — это, фактически, $0.00001$ (и ещё какие-то знаки, в которых мы не можем быть уверены).

В памяти компьтера оба числа хранятся в *экспоненциальной форме*, то есть в виде[^2] $1.23456789\times 10^8$ и $1.23456789\times 10^{-5}$.

Когда мы говорим про пять значащих цифр, мы имеем в виду цифры $1.2345$ *мантиссы*.

То, что мы сделали погрешность относительной, позволило нам вычислять корни любого порядка, однако, точность вычислений гораздо меньше, чем могла бы быть.
Тип `f64` позволяет хранить 15–17 значащих цифр, то есть мы можем использовать погрешность от `10e-15` до `10e-17`.
Такой разброс в величинах объясняется тем, что числа в компьютере хранятся в двоичном виде и содержат ровно 52 значащих бита.
Точность плавает из-за перевода чисел в десятичную систему.

Чтобы достичь максимальной возможной точности, мы должны взять погрешность, представленную в двоичной системе.

Для типа `f64` она равна $2^{-52}$ или $2.2204460492503131\times 10^{-16}$.
Вместо того, чтобы считать её вручную, мы можем взять константу `f64::EPLISON` и использовать её вместо числа $0.00001$.
Это даст нам вычислить квадратный корень с масимальной возможной точностью.

```rust
pub fn sqrt(x: f64) -> f64 {
    if x < 0.0 {
        return f64::NAN;
    }

    let error = x * f64::EPSILON;
    let mut a = x / 2.0;

    while (a * a - x).abs() > error {
        a = (a + x / a) / 2.0;
    }

    a
}
```

Константа `f64::EPSILON` называется *машинный эпсилон*. В C это `DBL_EPSILON`, а в C++ — `std::numeric_limits<double>::epsilon()`. Java предоставляет метод `Math.ulp()`, который возвращает произведение `x * f64::EPSILON`.

В мире .NET ситуация вышла из под-контроля. В стандартной библиотеке есть константа `Double.Epsilon` которая равна наименьшему в принципе представимому числу больше нуля. Она равна $4.94065645841247\times 10^{-324}$ и не подходит для вычислений с наибольшей точностью.

Длительное время программисты, писавшие на C#, VB.NET или F#, определяли машинный эпсилон вручную. В 2019 году вышла третья версия .NET Core, где, наконец, появились методы `Math.BitIncrement()` и `Math.BitDecrement()`, с помощью которых можно вычислить погрешность.

## Упражнения

<dl>
  <dt>Задача 1.3.1.</dt>
  <dd>
  Напишите функцию вычисления кубического корня.
  Обратите внимание, что параметр `x` может принимать отрицательные значения, а погрешность `error` должна быть гарантированно больше 0.
  </dd>

  <dt>Задача 1.3.2.</dt>
  <dd>
  Напишите функцию вычисления корня любой целой степени $n >= 2$.
  </dd>
</dl>

[^1]: Буква *a* — первая буква слова *approximation*, то есть *приближение*.

[^2]: Для простоты изложения числа показаны в десятичной системе, но хранятся они, конечно, в двоичной.
