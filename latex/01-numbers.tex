\chapter{Числа}

\section{Минимум двух чисел}

\subsection{Целые числа}

\begin{Exercise}
    \Question
    Виктор ходит на обед либо в кафе DevOps, либо в ресторан «Ни рыба, ни мясо».
    В кафе у него накопилась скидка в 20\%, бизнес-ланч там стоит 250 рублей.
    Скидка в ресторане составляет 30\%, но бизнес-ланч стоит 400 рублей.
    У Виктора осталось не так много денег до зарплаты и он не хочет тратить лишние деньги.
    Помогите ему определить самый дешёвый бизнес-ланс.
\end{Exercise}

Эта задача может показаться совершенно примитивной.
Трудно представить, что здесь может идти речь о каких бы то ни было алгоритмах.
Между тем, определение процентов и минимума двух чисел~--- хорошие примеры простых алгоритмов.

Сначала разберёмся с процентами.
Чтобы посчитать $p$ процентов от числа $n$, нужно $n$ умножить на $p/100$.

\begin{lstlisting}[language=Rust]
    pub fn percent(n: i32, p: i32) -> i32 {
        n * p / 100
    }
\end{lstlisting}

Простейшие алгоритмы представляют из себя последовательные вычисления без условий и циклов.

Теперь мы без труда можем посчитать процент от стоимости бизнес-ланча.

\begin{lstlisting}[language=Rust]
    let result = percent(250, 20); // 50
\end{lstlisting}


Впрочем, нас интересует не сумма скидки, а стоимость бизнес-ланча с учётом скидки.
Вместо $20\%$ мы должны использовать дополнение до $100$, то есть $(100 - 20)\%$.

\begin{lstlisting}[language=Rust]
    let result = percent(250, 100 - 20); // 200
\end{lstlisting}

Разобравшись с процентами, напишем функцию определения минимума.

\begin{lstlisting}[language=Rust]
    pub fn min(a: i32, b: i32) -> i32 {
        if a < b {
            a
        } else {
            b
        }
    }
\end{lstlisting}

Я знаю, как ужасно звучит, когда автор пишет сложный код и утверждает, что он очевиден, но здесь код и правда очевиден.
Из двух переданных параметров функция \texttt{min()} возвращает тот, который меньше, а если они равны, то второй.

\begin{lstlisting}[language=Rust]
    let result = min(percent(250, 100 - 20), percent(400, 100 - 30)); // 200
\end{lstlisting}

\subsection{Обобщение}

Rust~--- язык с сильной типизацией.
Если мы написали функцию, которая работает с целыми знаковыми числами \texttt{i32}, мы не можем вызывать её для беззнаковых чисел \texttt{u32} или больших чисел \texttt{i64}.

В идеале нам бы хотелось написать универсальную функцию, которая будет работать со всеми типами, которые можно сравнить друг с другом.
В Rust это совсем нетрудно сделать.

\begin{lstlisting}[language=Rust]
    pub fn min2<T>(a: T, b: T) -> T where T: Ord {
    if a < b {
        a
    } else {
        b
    }
}
\end{lstlisting}

Этот обобщённый (generic) код похож на обобщённый код из C++, Java и C\#, так что, кажется, не требует объяснений.
Если вы никогда раньше не сталкивались с обобщённым типами, прочитайте [нужную главу](https://doc.rust-lang.ru/book/ch10-01-syntax.html) из учебника по языку Rust.

В данном коде нас дожен заинтересовать \textit{типаж} \texttt{Ord}.
Его реализуют все типы, которые можно сравнивать, в том числе и целые числа.
Если тип \texttt{T} реализует \texttt{Ord} (на это указывает конструкция \texttt{where T: Ord}), мы можем применить оператор "меньше" (<) к переменным типа \texttt{T}.

Эта магия работает благодаря компилятору Rust, для которого \texttt{Ord}~--- особый типаж. Без магии код функции \texttt{min2<T>()} выглядит так.

\begin{lstlisting}[language=Rust]
    pub fn min2<T>(a: T, b: T) -> T where T: Ord {
    use std::cmp::Ordering;

    match a.cmp(&b) {
        Ordering::Less => a,
        Ordering::Equal => b,
        Ordering::Greater => b,
    }
}
\end{lstlisting}

Новая функция \texttt{min2<T>()} делает то же самое, что и старая функция \texttt{min}, но, в отличие от первой, может работать с любыми сравнимыми объектами, даже с теми, которые мы напишем сами.

\subsection{Сведние задачи к уже решённой}

Предположим, в истории о бизнес-ланче Виктора надо сравнить не два, а три заведения со скидками.
Тогда нам потребуется функция, которая возвращает минимум из трёх чисел.

Её нетрудно написать с помощью оператора \texttt{if/else}, но этот код будет громоздким.
Программисты, решая чуть более сложную задачу, часто используют существующее решение, так сказать, сводят новую задачу к решённой.
Вместо того, чтобы писать вложенные операторы \texttt{if/else}, вызовем функцию \texttt{min2<T>} два раза.

\begin{lstlisting}[language=Rust]
    pub fn min3<T>(a: T, b: T, c: T) -> T where T: Ord {
    min2(a, min2(b, c))
}
\end{lstlisting}

Такое решение не только занимает меньше места, но и проще читается.
В этой функции мы сначла находим наименьшее из чисел \texttt{b} и \texttt{c}, а затем победителя сравниваем с \texttt{a}.

\subsection{Сравнение чисел с плавающей запятой}

Если вам доводилось работать с числами с плавающей запятой, вы знаете, что они несколько \textit{магические}.
Они живут по каким-то своим законам, с которыми не так просто разобраться.

Если мы попробуем сравнить два числа с плавающей запятой, наша программа просто не скомпилируется.

\begin{lstlisting}[language=Rust]
    let result = min2(2.7182, 3.1415); // the trait `Ord` is not implemented for `{float}`
\end{lstlisting}

Сообщение об ошибке звучит странно: типаж \texttt{Ord} не реализован для типа \texttt{float}. Почему Rust не позволяет сравнивать числа с плавающей запятой?

В этом есть смысл. Типаж \texttt{Ord} доступен только для тех типов, в которых порядок определён для любых значений. Сюда попадают все целые типы, символы ASCII, даты, строки и многие другие типы.

Однако у чисел с плавающей запятой есть несколько специальных значений, одно из которых это \textit{Not a Number} или \texttt{NaN}. Оно возникает в процессе вычислений, если мы выполняем некорректную операцию, например, делим ноль на ноль.

Поскольку \texttt{NaN} не является числом, его нельзя сравнивать с другими числами с плавающей запятой.
Именно поэтому типаж \texttt{Ord} не реализован для типа \texttt{float}.
Что же делать?

Для представления типов, которые можно сравнивать, но не всегда, в Rust существует типаж \texttt{PartialOrd}.

\begin{lstlisting}[language=Rust]
    pub fn partial_min2<T>(a: T, b: T) -> Option<T> where T: PartialOrd {
    use std::cmp::Ordering;

    match a.partial_cmp(&b) {
        Some(Ordering::Less) => Some(a),
        Some(Ordering::Equal) => Some(b),
        Some(Ordering::Greater) => Some(b),
        None => None,
    }
}
\end{lstlisting}

Обратите внимание на тип \texttt{Option<T>}.
Этот обобщённый тип представляет *\textit{опциональное} значение.
В контексте нашей функции это значит, что если параметры \texttt{a} и \texttt{b} сравнимы, она возвращает наименьший, а если нет~--- не возвращает ничего.

В таких языках, как Pascal, C, C++, Java и C\# для представления отсутствующих величин часто используют указатель \texttt{null} (в Pascal он называется \texttt{nil}, в C~--- \texttt{NULL}).
К сожалению, при работе с ним постоянно возникает проблема \textit{NPE}, по названию исключения \texttt{NullPointerException} из Java.

В Rust такой проблемы возникнуть не может, поскольку нельзя \textit{вытащить} значение из \texttt{Option<T>} не проверив предварительно, что оно там есть\footnote{
    Это не совсем так.
    Вы вполне можете устроить панику, \textit{вытащив} значение без всякой проверки с помощью метода \texttt{unwrap()}.
    Метод удобен при прототирировании или изучении языка, но не вызывайте его в продуктовом коде.}.

\subsection {Упражнения}

\begin{Exercise}
    \Question
    Напишите обобщённую версию функции \texttt{max2<T>()}, которая возвращает наибольший из двух параметров.
\end{Exercise}
    
\begin{Exercise}
    \Question
    Напишите обобщённую версию функции \texttt{partial\_min3<T>()} которая возвращает наименьший из трёх параметров или \texttt{None}, если среди параметров есть такие, которые нельзя сравнивать.
\end{Exercise}
