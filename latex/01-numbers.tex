\chapter{Числа}

Обычно алгоритмы сопоставляют со структурами данных.
Именно так называется одна из книг Никлауса Вирта\footnote{
  Никлаус Вирт~--- один из столпов современной разработки~--- придумал язык Pascal и написал эссе «О вреде оператора GO TO», где популяризовал {\em структурное программирование}.
  А ещё он придумал {\em семафоры}.
}~--- «Алгоритмы + структуры данных = программы».

Но понятие алгоритма возникает уже при работе с самыми примитивными типами, такими как числа и символы ASCII.

Поэтому первые главы мы посвятим изучению алгоритмов, которые работают с отдельными числами, парами и тройками чисел, а также с простыми символами ASCII.

\section{Минимум двух чисел}

\subsection{Целые числа}

\begin{Exercise}
  \Question
  Виктор ходит на обед либо в кафе DevOps, либо в ресторан «Ни рыба, ни мясо».
  В кафе у него накопилась скидка в 20\%, бизнес-ланч там стоит 250 рублей.
  Скидка в ресторане составляет 30\%, но бизнес-ланч стоит 400 рублей.
  У Виктора осталось не так много денег до зарплаты и он не хочет тратить лишние деньги.
  Помогите ему определить самый дешёвый бизнес-ланс.
\end{Exercise}

Эта задача может показаться совершенно примитивной.
Трудно представить, что здесь может идти речь о каких бы то ни было алгоритмах.
Между тем, определение процентов и минимума двух чисел~--- хорошие примеры простых алгоритмов.

Сначала разберёмся с процентами.
Чтобы посчитать \code{p} процентов от числа \code{n}, нужно \code{n} умножить на \code{p/100}.

\begin{lstlisting}[language=Rust]
pub fn percent(n: i32, p: i32) -> i32 {
  n * p / 100
}
\end{lstlisting}

Простейшие алгоритмы представляют из себя последовательные вычисления без условий и циклов.
Теперь мы без труда можем посчитать процент от стоимости бизнес-ланча.

\begin{lstlisting}[language=Rust]
let result = percent(250, 20); // 50
\end{lstlisting}


Впрочем, нас интересует не сумма скидки, а стоимость бизнес-ланча с учётом скидки.
Вместо 20\% мы должны использовать дополнение до 100, то есть (100 - 20)\%.

\begin{lstlisting}[language=Rust]
let result = percent(250, 100 - 20); // 200
\end{lstlisting}

Разобравшись с процентами, напишем функцию определения минимума.

\begin{lstlisting}[language=Rust]
pub fn min(a: i32, b: i32) -> i32 {
  if a < b {
    a
  } else {
    b
  }
}
\end{lstlisting}

Я знаю, как ужасно звучит, когда автор пишет сложный код и утверждает, что он очевиден, но здесь код и правда очевиден.
Из двух переданных параметров функция \code{min()} возвращает тот, который меньше, а если они равны, то второй.

\begin{lstlisting}[language=Rust]
let result = min(percent(250, 100 - 20),
                 percent(400, 100 - 30)); // 200
\end{lstlisting}

\subsection{Обобщение}

Rust~--- язык с сильной типизацией.
Если мы написали функцию, которая работает с целыми знаковыми числами \code{i32}, мы не можем вызывать её для беззнаковых чисел \code{u32} или больших чисел \code{i64}.
В идеале нам бы хотелось написать универсальную функцию, которая будет работать со всеми типами, которые можно сравнить друг с другом.
В Rust это совсем нетрудно сделать.

\begin{lstlisting}[language=Rust]
pub fn min2<T>(a: T, b: T) -> T where T: Ord {
  if a < b {
    a
  } else {
    b
  }
}
\end{lstlisting}

Этот обобщённый (generic) код похож на обобщённый код из C++, Java и C\#, так что, кажется, не требует объяснений.
Если вы никогда раньше не сталкивались с обобщённым типами, прочитайте нужную раздел 10.1 \cite{rustlang} из учебника по языку Rust.

В данном коде нас дожен заинтересовать {\em типаж} \code{Ord}.
Его реализуют все типы, которые можно сравнивать, в том числе и целые числа.
Если тип \code{T} реализует \code{Ord} (на это указывает конструкция \code{where T: Ord}), мы можем применить оператор "меньше" (<) к переменным типа \code{T}.
Эта магия работает благодаря компилятору Rust, для которого \code{Ord}~--- особый типаж.
Без магии код функции \code{min2<T>()} выглядит так.

\begin{lstlisting}[language=Rust]
pub fn min2<T>(a: T, b: T) -> T where T: Ord {
  use std::cmp::Ordering;

  match a.cmp(&b) {
    Ordering::Less => a,
    Ordering::Equal => b,
    Ordering::Greater => b,
  }
}
\end{lstlisting}

Новая функция \code{min2<T>()} делает то же самое, что и старая функция \code{min}, но, в отличие от первой, может работать с любыми сравнимыми объектами, даже с теми, которые мы напишем сами.

\subsection{Сведение задачи к уже решённой}

Предположим, в истории о бизнес-ланче Виктора надо сравнить не два, а три заведения со скидками.
Тогда нам потребуется функция, которая возвращает минимум из трёх чисел.

Её нетрудно написать с помощью оператора \code{if/else}, но этот код будет громоздким.
Программисты, решая чуть более сложную задачу, часто используют существующее решение, так сказать, сводят новую задачу к решённой.
Вместо того, чтобы писать вложенные операторы \code{if/else}, вызовем функцию \code{min2<T>} два раза.

\begin{lstlisting}[language=Rust]
pub fn min3<T>(a: T, b: T, c: T) -> T where T: Ord {
  min2(a, min2(b, c))
}
\end{lstlisting}

Такое решение не только занимает меньше места, но и проще читается.
В этой функции мы сначла находим наименьшее из чисел \code{b} и \code{c}, а затем победителя сравниваем с \code{a}.

\subsection{Сравнение чисел с плавающей запятой}

Если вам доводилось работать с числами с плавающей запятой, вы знаете, что они несколько {\em магические}.
Они живут по каким-то своим законам, с которыми не так просто разобраться.
Если мы попробуем сравнить два числа с плавающей запятой, наша программа просто не скомпилируется.

\begin{lstlisting}[language=Rust]
// the trait `Ord` is not implemented for `{float}`
let result = min2(2.7182, 3.1415);
\end{lstlisting}

Сообщение об ошибке звучит странно: типаж \code{Ord} не реализован для типа \code{float}.
Почему Rust не позволяет сравнивать числа с плавающей запятой?

В этом есть смысл. Типаж \code{Ord} доступен только для тех типов, в которых порядок определён для любых значений.
Сюда попадают все целые типы, символы ASCII, даты, строки и многие другие типы.
Однако у чисел с плавающей запятой есть несколько специальных значений, одно из которых это {\em Not a Number} или \code{NaN}.
Оно возникает в процессе вычислений, если мы выполняем некорректную операцию, например, делим ноль на ноль.

Поскольку \code{NaN} не является числом, его нельзя сравнивать с другими числами с плавающей запятой.
Именно поэтому типаж \code{Ord} не реализован для типа \code{float}.
Что же делать?
Для представления типов, которые можно сравнивать, но не всегда, в Rust существует типаж \code{PartialOrd}.

\begin{lstlisting}[language=Rust]
pub fn partial_min2<T>(a: T, b: T) -> Option<T>
  where T: PartialOrd {
  use std::cmp::Ordering;

  match a.partial_cmp(&b) {
    Some(Ordering::Less) => Some(a),
    Some(Ordering::Equal) => Some(b),
    Some(Ordering::Greater) => Some(b),
    None => None,
  }
}
\end{lstlisting}

Обратите внимание на тип \code{Option<T>}.
Этот обобщённый тип представляет {\em опциональное} значение.
В контексте нашей функции это значит, что если параметры \code{a} и \code{b} сравнимы, она возвращает наименьший, а если нет~--- не возвращает ничего.

В таких языках, как Pascal, C, C++, Java и C\# для представления отсутствующих величин часто используют указатель \code{null} (в Pascal он называется \code{nil}, в C~--- \code{NULL}).
К сожалению, при работе с ним постоянно возникает проблема {\em  NPE}, по названию исключения \code{NullPointerException} из Java.

В Rust такой проблемы возникнуть не может, поскольку нельзя {\em вытащить} значение из \code{Option<T>} не проверив предварительно, что оно там есть\footnote{
  Это не совсем так.
  Вы вполне можете устроить панику, {\em вытащив} значение без всякой проверки с помощью метода \code{unwrap()}.
  Метод удобен при прототирировании или изучении языка, но не вызывайте его в продуктовом коде.}.

\subsection {Упражнения}

\begin{Exercise}
  \Question
  Напишите обобщённую версию функции \code{max2<T>()}, которая возвращает наибольший из двух параметров.
\end{Exercise}
    
\begin{Exercise}
  \Question
  Напишите обобщённую версию функции \code{partial\_min3<T>()} которая возвращает наименьший из трёх параметров или \texttt{None}, если среди параметров есть такие, которые нельзя сравнивать.
\end{Exercise}

\section{Алгоритм Евклида}

\subsection{Положительные числа}

\begin{Exercise}
  \Question
  На олимпиаду по программированию приехали 210 девочек и 252 мальчика.
  Мы хотим разбить их на команды так, чтобы во всех командах было одинаковое количество девочек и одинаковое количество мальчиков, например, везде 4 девочки и 7 мальчиков.
  Как много команд мы можем составить? Интересует максимально возможное число.
\end{Exercise}

Каково бы ни было количество команд, на него должны делиться и число 210, и число 252.
Нам нужен общий делитель двух чисел, а, учитывая, что нас интересует максимальное возможное число, речь идёт о {\em Наибольшем Общем Делителе}~--- НОД или, по-английски, GCD.

$$
gcd(210, 252) = 42
$$

Решение~--- мы можем составить 42 команды, в каждой из которых будет 5 девочек и 6 мальчиков.
Вы знаете ответ, потому что я посчитал за вас, чему равен НОД 210 и 252.

А как вычислить НОД самостоятельно?

Существует сложный алгоритм вычисления.
Он заключается в том, что мы разбиваем оба числа на простые множетели.
$210 = 2 \times 3 \times 5 \times 7$ и $252 = 2^2 \times 3^2 \times 7$.
Чтобы определить НОД надо перемножить числа, которые встречаются в обоих разложениях с наименьшей степенью.
$2 \times 3 \times 7 = 42$.
Разбиение на простые множества кажется нетривиальной задачей.

К счастью для нас, в глубокой древности люди научились вычислять НОД простым способом, а известный математик Евклид его записал.
Теперь этот способ называют {\em алгоритмом Евклида}.
Для начала выясним несколько фактов относительно наибольшего общего делителя.
\Strong{Факт первый:} не имеет значения, в каком порядке рассматривать числа, для которых мы вычисляем НОД.

$$
\gcd(a, b) = \gcd(b, a)
$$

Для упрощения рассуждений будем считать, что в записи $\gcd(a, b)$ параметр $a$ больше или равен $b$.
Если это не так, мы всегда можем поменять параметры местами.
Далее \Strong{факт второй}.

$$
\gcd(a, b) = \gcd(b, a \bmod b)
$$

Здесь $a \bmod b$~--- остаток от деления $a$ на $b$.
Почему это так?

Представим $a$ в виде $a = b q + r$, здесь $q$~--- частное от деления $a$ на $b$, а $r$~--- остаток.
У $a$ и $b$ есть общие делители, по меньше мере, оба числа всегда делятся на $1$.
Если на общий делитель делится $b$, значит, будет делиться и $b q$.
Тогда, с неизбежностью, на этот делитель должен делиться и остаток $r$.

Это рассуждение касается всех общих делителей $a$ и $b$, значит, $r$ делится на любой общий делитель, включая наибольший.
Следовательно, $\gcd(a, b) = \gcd(b, r)$, где $r = a \bmod b$.
Обратим внимание, что пара чисел $b$ и $r$ «меньше», чем $a$ и $b$.
По найшей договорённости, $a >= b$, а $r$, который является остатком от деления на $b$ всегда меньше $b$ ($0 <= r < b$).
Применяя трюк в вычислением остатка и получая меньшие пары чисел, мы, в конце концов, доберёмся до вырожденного случая, к которому относится \Strong{третий факт}.

$$
gcd(a, 0) = a
$$

Возможно, он выглядит странно, но рассуждения нас не подведут: и число $a$, и число $0$ можно разделить на $a$.
Алгоритм Евклида заключается в том, что мы вычисляем остатки от деления, пока не достигнем вырожденного случая.
Мы знаем, что на каждом шаге НОД будет оставаться неизменным (второЙ факт).
На последнем (вырожденном) шаге, второй параметр всегда будет равен $0$, а первый~--- искомому НОД.

\begin{lstlisting}[language=Rust]
pub fn gdc(a: u32, b: u32) -> u32 {
  let (mut a, mut b) =
    if a > b {
      (a, b)
    } else {
      (b, a)
    };

  while b != 0 {
    (a, b) = (b, a % b);
  }

  a
}
\end{lstlisting}

В первых строках функции мы гарантируем, что \code{a >= b}, а, если это не так, меняем параметры местами.
Здесь и в основном цикле для обмена значениями мы пользуемся развитой системой типов Rust, а именно кортежами.

Запись \code{(a, b) = (b, a \% b)} означает, что одновременно будут выполнены присвоения \code{a = b} и \code{b = a \% b}, при этом Rust проследит за тем, чтобы при вычислении \code{b} использовалось старое значение \code{a} и наоборот.
В языках без кортежей нам бы пришлось вводить вспомогательную переменную, которую традиционно называют \code{t} или \code{tmp} от англиского слово {\em temporary} — временный.

\begin{lstlisting}[language=Rust]
  while b != 0 {
    let tmp = b;
    b = a % b; \/\/ мы потеряли старое значение b
    a = tmp; \/\/ поэтому здесь присваиваем переменную tmp, 
             \/\/где сохранили старое значение b
  }
\end{lstlisting}

Алгоритм Евклида~--- хорошая иллюстрация понятия {\em алгоритм} в целом.
С одной стороны, он не примитивный, содержит условие и цикл, требует обоснования корректности, с другой~--- он всё ещё достаточно простой.

\subsection{Упражнения}

\begin{Exercise}
  \Question
  Мы рассмотрели алгоритм Евклида для положительных чисел.
  Однако, его можно применять и к любым целым числам.
  По определению, $\gcd(a, b) = \gcd(|a|, |b|)$.
  Реализуйте алгоритм Евклида для чисел типа \code{i32}.
\end{Exercise}

\section{Квадратный корень}

В стандартной библиотеке любого языка есть функция вычисления квадратного корня.
Когда я не знал, как она устроена, она казалась мне {\em волшебной}.
Синус можно посчитать по формуле Тейлора (мы сделаем это в следующей главе).
Но квадратный корень обычно вычисляют по-другому.
Как же работает функция \code{sqrt}?

\subsection{Начнём с практики}

Конечно, вычисление квадратного корня имеет не только теоретическую ценность.
В компьютерных играх для построения кратчайшего пути используется алгоритм А*, которому нужно вычислять расстояние между точками «по прямой», без учёта препятствий.
Каждая точка задаётся двумя координами, а расстояние ввычисляется по теореме Пифагора.

$$
d = \sqrt {(x_2 - x_1)^2 + (y_2 - y_1)^2}
$$

\begin{Exercise}
  \Question
  Алексей пишет компьтерную игру.
  Ему надо реализовать алгоритм А*, а для этого надо научиться вычислять квадратный корень.
  К сожалению, игра запускается на микроконтроллере и ей недоступна стандартная библиотека Rust.
  Помогите Алексею написать функцию вычисления квадратного корня.
\end{Exercise}

\subsection{Проектирование функции}

Квадратный корень вычисляется для неотрицательных чисел.
В стандартной библиотеке редко учитывают {\em комплексные числа}, и если параметр функции отрицательный, надо предусмотреть какое-нибудь разумное поведение.
Один из вариантов~--- возвращать \code{Option<f64>}.
В случае, если мы не можем вычислить квадратный корень, мы просто возвращаем \code{None}.
К сожалению, это усложняет наши формулы, потому что мы не можем складывать или делить числа разных типов~--- \code{f64} и \code{Option<f64>}.

Второй вариант~--- вызывать панику и останавливать программу.
Для реального промышленного кода этот подход слишком кардинальный.

Наконец, мы можем возвращать {\em особое значение}, которое будет означать отсутствие решения.
К счастью, у типов с плавающей точкой есть константа \code{NaN} (Not a Number — Не Число), которая как раз и означает результат операции, которую невозможно выполнить.

Пусть наш вариант функции \code{sqrt} будет принимать значение типа \code{f64} и возвращать значение типа \code{f64}, в частности, \code{f64::NAN}, если \code{x} меньше нуля.

\begin{lstlisting}[language=Rust]
pub fn sqrt(x: f64) -> f64 {
  if x < 0.0 {
    return f64::NAN;
  }

  // ...
}
\end{lstlisting}

Что дальше?

\subsection{Вавилонский метод}

{\em Вавилонский метод} или {\em метод Герона}~--- простой и, вероятно, самый древний алгоритм вычисления квадратного корня.
Он основывается на том соображении, что если какое-то число $a, 0 < a <= x$ больше $\sqrt x$, то $x/a$~--- меньше.
Обратное утверждение также верно: если $a < \sqrt x$, то $x/a > \sqrt x$.
Логично предположить, что среднее арифметическое этих чисел будет ближе к корню, чем $a$.
В данном случае буква {\em a}~--- первая буква слова {\em approximation}, то есть {\em приближение}.

Повторяя вычисления, мы будем всё точнее вычислять квадратный корень.
Это утверждение не кажется очевидным.
Его доказательство опирается на неравенство среднего арифметического и среднего геометрического.

$$
\sqrt {a b} <= \frac{a + b}{2}
$$

На каждом шаге среднее арифметическое всё ближе к корню и при этом всегда больше либо равно ему.
Алгоритм в таком виде не пригоден для практического применения, поскольку он никогда не заканчивается, всё точнее и точнее вычисляя корень.
Нам же важно остановиться, и как можно раньше.
Код вычисления корня должен быть быстрым.

Мы можем остановиться, когда достигнем нужной точности.
Получив очередное приближение $a$, вычислим $|a^2 - x|$.
Если результат достигает, например 0.00001, останавливаемся и возвращаем $a$.
Напишем первую версию функции.

\begin{lstlisting}[language=Rust]
pub fn sqrt(x: f64) -> f64 {
  if x < 0.0 {
    return f64::NAN;
  }

  let error = 0.00001;
  let mut a = x / 2.0;
  
  while (a * a - x).abs() > error {
    a = (a + x / a) / 2.0;
  }

  a
}
\end{lstlisting}

\subsection{Погрешность абсолютная и относительная}

В качестве первого приближения мы взяли половину аргумента.
Мы можем использовать любое число больше нуля, и половина аргумента ничем не хуже других вариантов.
Этот код справляется с вычислением квадратных корней для чисел вроде 2, 20 или 2000.
Однако, он пасует перед маленькими числами, такими как 0.000002.

Эта ошибка часто встречается в учебном коде.
В промышленном коде погрешность (переменная \code{error}) должна быть не {\em абсолютной}, а {\em относительной} величиной.
В общем случае она должна быть равна $0.00001 |x|$, но поскольку в нашем случае $x > 0$, мы можем избавиться от модуля и положить погрешность равной $0.00001 x$.

\begin{lstlisting}[language=Rust]
pub fn sqrt(x: f64) -> f64 {
  if x < 0.0 {
    return f64::NAN;
  }

  let error = x * 0.00001;
  let mut a = x / 2.0;
  
  while (a * a - x).abs() > error {
    a = (a + x / a) / 2.0;
  }

  a
}
\end{lstlisting}

При вычислении погрешности есть {\em вырожденный случай} при $x = 0$.
В этом случае переменная \code{error} также становится равной 0.
Мы должны были бы как-то проверять этот случай в коде, но, к счастью, именно здесь нас защищает сама логика сравнения.
Цикл продолжается только если очередное приближение {\em больше} погрешности, а при $x = 0$ мы получаем сравнение $0 < 0$, результат которого {\em ложь}.
Иными словами, при $x = 0$ цикл не будет выполен ни разу.

\subsection{Минимальная погрешность}

Эта версия работает гораздо лучше, но она всё ещё не идеальна.
Сейчас она вычисляет корень с точностью в пять значащих цифр (пятая может быть результатом округления).
Обратие внимание, что речь идёт не пяти цифрах после запятой, а о пяти значащих цифрах.
Пять цифр после запятой теряют смысл, когда мы говорим об очень больших или очень маленьких числах, таких как 123456789 и 0.0000123456789.

Число 123456789 превращается в 123456789.00000.
Пять знаков после запятой для него~--- это чрезмерная точность.
В то же время 0.0000123456789~--- это, фактически, 0.00001 (и ещё какие-то знаки, в которых мы не можем быть уверены).

В памяти компьтера оба числа хранятся в {\em экспоненциальной форме}, то есть в виде\footnote{
  Для простоты изложения числа показаны в десятичной системе, но хранятся они, конечно, в двоичной.
} $1.23456789\times 10^8$ и $1.23456789\times 10^{-5}$.

Когда мы говорим про пять значащих цифр, мы имеем в виду цифры 1.2345 {\em мантиссы}.

То, что мы сделали погрешность относительной, позволило нам вычислять корни любого порядка, однако, точность вычислений гораздо меньше, чем могла бы быть.
Тип \code{f64} позволяет хранить 15–17 значащих цифр, то есть мы можем использовать погрешность от $10^{-15}$ до $10^{-17}$.
Такой разброс в величинах объясняется тем, что числа в компьютере хранятся в двоичном виде и содержат ровно 52 значащих бита.
Точность плавает из-за перевода чисел в десятичную систему.
Чтобы достичь максимальной возможной точности, мы должны взять погрешность, представленную в двоичной системе.

Для типа \code{f64} она равна $2^{-52}$ или $2.2204460492503131\times 10^{-16}$.
Вместо того, чтобы считать её вручную, мы можем взять константу \code{f64::EPLISON} и использовать её вместо числа 0.00001.
Теперь вычисляем квадратный корень с масимальной возможной точностью.

\begin{lstlisting}[language=Rust]
pub fn sqrt(x: f64) -> f64 {
  if x < 0.0 {
    return f64::NAN;
  }

  let error = x * f64::EPSILON;
  let mut a = x / 2.0;

  while (a * a - x).abs() > error {
    a = (a + x / a) / 2.0;
  }

  a
}
\end{lstlisting}

Константа \code{f64::EPSILON} называется {\em машинный эпсилон}.
В C это \code{DBL\_EPSILON}, а в C++~--- \code{std::numeric\_limits<double>::epsilon()}.
Java предоставляет метод \code{Math.ulp()}, который возвращает произведение \code{x * f64::EPSILON}.

В .NET ситуация вышла из под-контроля.
В стандартной библиотеке есть константа \code{Double.Epsilon} которая равна наименьшему в принципе представимому числу больше нуля.
Она равна $4.94065645841247\times 10^{-324}$, что гораздо меньше машинного эпсилона.
В действительности, она не подходит для вычислений с наибольшей точностью, а только вводит в заблуждение.

Длительное время программисты, писавшие на C\#, VB.NET или F\#, определяли машинный эпсилон вручную.
В 2019 году вышла третья версия .NET Core, где, наконец, появились методы \code{Math.BitIncrement()} и \code{Math.BitDecrement()}, с помощью которых можно вычислить погрешность.

\subsection{Упражнения}

\begin{Exercise}
  \Question
  Напишите функцию вычисления кубического корня.
  Обратите внимание, что параметр \code{x} может принимать отрицательные значения, а погрешность \code{error} должна быть гарантированно больше 0.
\end{Exercise}

\begin{Exercise}
  \Question
  Напишите функцию вычисления корня любой целой степени $n >= 2$.
\end{Exercise}

\section{Синус}

Синус вычисляют по формуле Тейлора.

$$
\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots + (-1)^n \frac{x^{2n + 1}}{(2n + 1)!}
$$

Очевидно, синус вычисляется в цикле.
На каждом шаге определяется следующий элемент последовательности и прибавляется к {\em аккумулятору}.
Аккумулятор~--- общепринятое название переменной, которая накапливает (аккумулирует) значение-результат.
Аккумулятор может содержать сумму, произведение, побитовые операции И/ИЛИ, да и в целом всё, что угодно.

\subsection{Проектируем реализацию}

В преыдущей главе мы познакомлись с понятиями {\em погрешности} и {\em машинного эпсилона}.
При вычислении синуса погрешность нам также потребуется.
Какой может быть погрешность при вычислении синуса?
Мы не можем просто вычислить её через \code{x}, поскольку для синуса параметр может быть и положительным, и отрицательным.
Поэтому мы берём абсолютное значение \code{x} и умножаем на машинный эпсилон, чтобы получить положитульную погрешность.

Однако, это нужно только для небольших значений \code{x}, когда результат функции тоже небольшой.
При {\em больших} значениях параметра, таких как 10 или даже 1000, синус всё равно будет не больше единицы.
А это значит, что наибольшая погрешность также равна \code{f64::EPSILON}.

Теперь подумаем об организации цикла.
Последовательносить элементов в ряде Тейлора~--- убывающая (иначе бы он не сходился).
Значит, на каком-то шаге очередной элемент станет меньше погрешности.
В этот момент мы должны остановить вычисления и вернуть значение аккумулятора.

Основываясь на этих соображениях, создадим первый набросок функции.

\begin{lstlisting}[language=Rust]
pub fn sin(x: f64) -> f64 {
  let error = {
    let x = x.abs();
    if x < 1.0 {
      x * f64::EPSILON
    } else {
     f64::EPSILON
    }
  };

  let mut element = x;
  let mut accumulator = 0.0.;
    
  while element.abs() > error {
    // ...
  }

  accumulator
}
\end{lstlisting}

\subsection{Вычисления в цикле}

Мы могли бы на каждом шаге вычислять очередной элемент по формуле $\frac{x^{2n + 1}}{(2n + 1)!}$, но это слишком расточительно.
Предположим, нам известны значения $x^5$ и $5!$ и мы хотим вычислить $x^7$ и $7$.
Можно было бы заново перемножать $x\times x\times x\times x\times x\times x\times x$ и $1\times 2\times 3\times 4\times 5\times 6\times 7$, однако, у нас уже есть $x\times x\times x\times x\times x$ и $1\times 2\times 3\times 4\times 5$.

Гораздо быстрее воспользоваться формулами $x^7 = x^5\times x\times x$ и $7! = 5!\times 6\times 7$.
Запишем эту идею в коде.

\begin{lstlisting}[language=Rust]
  // ...
  let mut n = 1;
  let mut element = x;
  let mut accumulator = 0.0;

  while element.abs() > error {
    accumulator += element;
    element = element * x * x / f64::from((n + 1) * (n + 2));
    n += 2;
  }

  accumulator
  // ...
\end{lstlisting}

Переменная \code{n} имеет целый тип, но все остальные выражения в формуле~--- плавающие, поэтому мы приводим выражение \code{(n+ 1) * (n + 2)} к типу \code{f64}.
Осталось разобраться со знаком.
В формуле Тейлора нечётные элементы последовательноси {\em складываются}, а чётные~--- вычитаются.
Чтобы не писать сложную логику, заметим, что каждый следующий элемент имеет противоположный знак.
Достаточно добавить унарный минус в выражение \code{element * x * x / f64::from((n + 1) * (n + 2))}, и больше ничего.
В законченном виде наша функция выглядит так.

\begin{lstlisting}[language=Rust]
pub fn sin(x: f64) -> f64 {
  let error = {
    let x = x.abs();
    if x < 1.0 {
      x * f64::EPSILON
    } else {
      f64::EPSILON
    }
  };

  let mut n = 1;
  let mut element = x;
  let mut accumulator = 0.0;

  while element.abs() > error {
    accumulator += element;
    element = -element * x * x / f64::from((n + 1) * (n + 2));
    n += 2;
  }

  accumulator
}
\end{lstlisting}

И она работает.

\subsection{Упражнения}

\begin{Exercise}
  \Question
  Реализуйте функцию косинус.
\end{Exercise}

\begin{Exercise}
  \Question
  Реализуйте функцию тангенс.
\end{Exercise}
