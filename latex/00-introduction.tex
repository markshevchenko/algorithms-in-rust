\chapter{Введение}

Версия \input{../version.txt}

\section{История}

Пару лет назад в одном из Telegram-чатов мы обсуждали, какая из книг по алгоритмам лучше.
Участники не смогли прийти к общему мнению, но во время дискуссии меня посетила интересная мысль.
Сам я предпочитаю трёхтомник Кнута~--- это фундаментальная книга, где можно регулировать уровень погружения.
Вы можете читать только описания алгоритмов, пропуская при этом {\em математику} и не делая упражнений.

Однако, алгоритмы в книге Кнута реализованы на {\em вымышленном языке ассемблера}\footnote{Он называется MIX.}.
В 60-е года XX века компьютеры были слабее и я язык ассемблера использовался часто.
Но даже тогда использование низкоуровнего языка в книге по алгоритмам затрудняло их понимание.
Разбираясь со сложным алгоритмом, нужно было много времени тратить на детали реализации, поскольку на низком уровне без них программировать невозможно.
Хорошей альтернативой стала книга Никлауса Вирта "Алгоритмы\ + Структуры данных\ = Программы".
Вирт выбрал высокоуровневый язык Pascal, который считается очень понятным и широко использовался для обучения.
Впрочем, сейчас язык ушёл из большой индустрии.
Придя на работу, вы будете писать на чём-то другом.

Современные курсы по алгоритмам предпочитают распространённые языки, такие как Python и JavaScript.
У них низкий порог входа, их многие знают и они широко представлены в вакансиях.
Однако для изучения алгоритмов эти языки~--- слишком высокого уровня.
При проектировании алгоритмов важными вопросами является производительность и экономия памяти.
Иногда вы явным образом хотите использовать быстрые операции (целочисленную или битовую арифметику) и контролировать способ размещения объектов в памяти компьютера.
Python и JavaScript этого не позволяют.
Кроме того, Python и JavaScript~--- интепретируемые языки и поэтому не очень быстрые.
Далеко не каждый алгоритм может быть эффективно реализован на них.

Что же вместо ассемблера, Python или Pascal?
Язык программирования Rust~--- высокоуровневый, с развитой системой типов.
Его выразительности хватит, чтобы описывать алгоритмы, избегая низкоуровневых подробностей.
С другой стороны, это системный язык, позволяющий точно определять типы данных (\c{u8}, \c{i32}, \c{f64}), использовать битовые операции, размещать сложные объекты на стеке.
В отличие от Python или Java, Rust позволяет рассуждать о роизводительности и работе с памятью.
В отличие от C++ он компактный, я бы даже сказал~--- стройный.

Мне было очевидно, что современный учебник по алгоритмам должен ориентироваться на Rust.
Но такого учебника не было, и я решил его написать.

\section{Аудитория}

При написании книги очень важно обрисовать аудиторию.
Долгие годы программирование было связано с {\em прикладной математикой}.
Для того, чтобы стать программистом, надо было получить высшее образование.
В качестве пособия в институтах использовался или учебник Кнута, или учебник Кормена, где не только разбираются алгоритмы, но и даются математически точные определия, и доказывают теоремы.

В 1990-е и 2000-е ситуация изменилась.
В индустрию пришли специалисты без образования, способные решать большинство практических задач.
Кнут и Кормен не то, чтобы сложные для этих специалистов~--- они избыточные.
Практикам не нужны точные определения, им хватит интуитивных.
Строгому доказательству они предпочтут нестрогое.

Спорным является вопрос, наксколько простым может быть изложение.
Практик~--- это не тот, кто знает и использует готовые алгоритмы, но и тот, кто, в случае необходимости, может спроектировать алгоритм и оценить его производительность.
Практику нужна теоретическая подготовка. Книга Бхаргавы Адитьи «Грокаем алгоритмы» для него слишком проста.

Таким образом, аудитория этой книги~--- программисты без профильного образования, без высшего образования, те, кто получил не очень хорошее образование и хотел бы подтянуть свой уровень.

\section{Как читать книгу}

Если какие-то объяснения покажутся вам сложными, вы можете их пропустить.
Или разбораться~--- это может быть даже лучше.
Но сложный текст не должен вас останавливать.
Если не понимаете материал и не можете разобраться, переходите к следующей главе.
Главы рассказывают о разных алгоритмах, которые могут быть проще, чем тот, на котором вы застряли.

Сам материал составлен так, чтобы его можно было читать последовательно.
Вторая глава может рассказывать о чём-то таком, что пригодится в пятой главе, но не наоборот.
Последний принцип, как бы он ни был правилен, на практике недостижим.
В реальной жизни знания связаны, а не разбиты на главы и разделы и забегать вперёд всё равно приходится.
В таких случаях я буду явно обозначать ситуацию и ссылаться на главу, где все ветки сойдутся воедино.

\section{Rust}

Важной частью повествования будут примеры на языке Rust, в связи с чем автор ожидает, что читатель с ним знаком.
Я рекомендую прочитать один из учбеников по Rust (в числе которых есть бесплатный RustBook \cite{rustbook}, в том числе, переведённый на русский язык \cite{rustbook_ru}).

Впрочем, зная, как я сам изучаю новые предметы~--- в стиле «головой в омут»~--- предположу, что часть читателей решится читать книгу сразу, не сильно вникая в язык.

Это вполне возможно, поскольку синтаксис Rust схож с C, C++, Java и C\sharp.
Существуют небольшие, но важные отличия, которые я буду отмечать прямо в тексте.
Даже если вы предпочитаете этот стиль, перед чтением книги разберитесь с тем, как устроены проекты Rust, как их создавать и запускать.

\section{Версии}

Работа над книгой идёт постепенно. Я пишу её в соответствии с содержанием, время от времени внося правки в уже написанный текст.

Для удобства читателя, книга снабжена {\em номером версии}, который вы найдёте в самом начале Введения.

\section{Пожертвования}
