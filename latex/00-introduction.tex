\chapter{Введение}

Версия \input{../version.txt}

\section{История}

Пару лет назад в одном из Telegram-чатов мы обсуждали, какая из книг по алгоритмам лучше.
Как всегда, участники не смогли прийти к общему мнению.
Однако во время дискуссии у меня появилась интересная мысль.
Сам я предпочитаю трёхтомник Кнута~--- это фундаментальная книга, где можно регулировать уровень погружения.
Вы можете читать только описания алгоритмов, пропуская при этом {\em математику} и не делая упражнений.

Но {\em вымышленный язык ассемблера}\footnote{Он называется MIX.}, на котором реализованы алгоритмы, затрудняет их понимание.
Это было проблемой уже в семидесятые, когда вышли первые тома.
Машины были гораздо слабее, поэтому ассемблеры использовались гораздо чаще, чем сейчас.
Но даже тогда, разбираясь со сложным алгоритмом, вам приходилось много времени тратить на детали реализации, поскольку без них программировать на низком уровне невозможно.
Хорошей альтернативой стала книга Никлауса Вирта "Алгоритмы + Структуры данных = Программы".
Вирт в качестве основного языка выбрал Pascal.
Не смотря на то, что этот язык считается очень понятным и широко использовался для обучения, сейчас он ушёл из большой индустрии.
Придя на работу, вы будете писать на чём-то языке.

Современные курсы по алгоритмам предпочитают распространённые языки, такие как Python и JavaScript.
У них низкий порог входа, их почти все знают и они широко представлены в вакансиях.
Однако эти языки слишком высокого уровня.
Одним из важных вопросов при проектировании алгоритмов является их производительность.
Python и JavaScript~--- интепретируемые языки. Общепринято, что они не очень быстрые, а, следовательно, далеко не каждый алгоритм имеет смысл на них писать.

Что же вместо ассемблера, Python или Pascal?~--- задался я вопросом.
Ответ пришёл сразу: только Rust.
Это высокоуровневый язык с развитой системой типов.
Его выразительности хватит, чтобы описывать алгоритмы, избегая низкоуровневых подробностей.
С другой стороны, это системный язык, близкий к железу.
В отличие от, например, Python или Java, он позволяет рассуждать о производительности и работе с памятью.
И он компактный, в отличие от С++.
Я бы даже сказал~--- стройный.

Я понял, что сегодня книга по алгоритмам должна ориентироваться на Rust.
К сожалению, такой книги не было.
И тогда я решил её написать.

\section{Аудитория}

При написании книги всегда очень важно обрисовать аудиторию.
Долгие годы программирование было связано с {\em прикладной математикой}.
Для того, чтобы стать программистов, надо было получить высшее образование.

Но в 1990-е и 2000-е ситуация изменилась.
В индустрию пришли специалисты без образования, способные, как оказалось, решать подавляющее большинство практических задач.
Однако современные издательства предлагают им либо учебники, опирающиеся на математику, которую не дают в школе, либо пособия со слабой теоретической базой.

Я большой поклонник понятного обучения~--- стараюсь избегать теоретических материалов, которые не опиратся на практику.
Поэтому я буду стараться очерчивать проблему и затем предлагать способы её решения.
С другой стороны, я люблю математику и считаю, что нет ничего практичнее хорошей теории.
Дав основной материал, я постараюсь закрепить его чуть более фундаментальными знаниями.

Если какие-то объяснения покажутся вам сложными, вы можете их пропустить.
Или разбораться~--- это может быть даже лучше.
Но сложный текст не должен вас останавливать.
Если не понимаете материал и не можете разобраться, переходите к следующей главе.

Сам материал составлен так, чтобы его можно было читать последовательно.
Вторая глава может рассказывать о чём-то таком, что пригодится в пятой главе, но не наоборот.
Последний принцип, как бы он ни был правилен, на практике недостижим.
В реальной жизни знания связаны, а не разбиты на главы и разделы.
Иногда, рассказывая о чём то одном, приходётся забегать вперёд и рассказывать о другом.
В этим случаях я буду явно обозначать ситуацию и ссылаться на главу, где все ветки сойдутся воедино.

\section{Версии}

\section{Пожертвования}
