\chapter{Символы ASCII}

В XXI неприлично использовать символы ASCII~--- все давно перешли на Unicode.
Впрочем, они хорошо подходят, чтобы изучать некоторые аспекты программирования.
ASCII (читается {\em аски}) — American Standard Code for Information Interchange.
Этот стандарт закрепил численные коды за основными печатными символами (включая буквы английского алфавита) и некоторыми широко используемыми управляющими символами.

Стандарт разрабатывался несколько лет и в современном виде опубликован в 1967 году.
В то время широкое распространение имели {\em телетайпы}~--- электронные пишущие машинки, используемые для ввода и вывода информации вместо {\em терминалов}.
Управляющие символы позволяли двигать каретку телетайпа, возвращать её в начало строки переводить на следующую строку.

До сих пор мы называем эти символы {\em возврат каретки} ({\em carriage return}) и {\em перевод строки} ({\em line feed}), хотя в наше время не только телетайпы, но и алфавитно-цифровые терминалы стали исторей.
Классическая таблица символов ASCII описывает 128 значений, то есть 7 битов из байта. Старший бит предполагалось использовать для контроля чётности, но в последствии от этой идеи отказались. ASCII стали расширять, в разных странах по разному, чтобы кодировать символы псевдографики и буквы местного алфавита.
Оригинальная таблица ASCII выглядит так.

%| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
%|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|----:|:---:|
%|  0|NUL|  1|SOH|  2|STX|  3|ETX|  4|EOT|  5|ENQ|  6|ACK|  7|BEL|  8| BS|  9| HT| 10| LF| 11| VT| 12| FF| 13| CR| 14| SO| 15| SI|
%| 16|DLE| 17|DC1| 18|DC2| 19|DC3| 20|DC4| 21|NAK| 22|SYN| 23|ETB| 24|CAN| 25| EM| 26|SUB| 27|ESC| 28| FS| 29| GS| 30| RS| 31| US|
%| 32|   | 33| ! | 34| " | 35| # | 36| $ | 37| % | 38| & | 39| ' | 40| ( | 41| ) | 42| * | 43| + | 44| , | 45| - | 46| . | 47| / |
%| 48| 0 | 49| 1 | 50| 2 | 51| 3 | 52| 4 | 53| 5 | 54| 6 | 55| 7 | 56| 8 | 57| 9 | 58| : | 59| ; | 60| < | 61| = | 62| > | 63| ? |
%| 64| @ | 65| A | 66| B | 67| C | 68| D | 69| E | 70| F | 71| G | 72| H | 73| I | 74| J | 75| K | 76| L | 77| M | 78| N | 79| O |
%| 80| P | 81| Q | 82| R | 83| S | 84| T | 85| U | 86| V | 87| W | 88| X | 89| Y | 90| Z | 91| [ | 92| \ | 93| ] | 94| ^ | 95| _ |
%| 96| ` | 97| a | 98| b | 99| c |100| d |101| e |102| f |103| g |104| h |105| i |106| j |107| k |108| l |109| m |110| n |111| o |
%|112| p |113| q |114| r |115| s |116| t |117| u |118| v |119| w |120| x |121| y |122| z |123| { |124| \||125| } |126| ~ |127|DEL|

Первые 32 символа, также, как и последний (с кодом 127)~--- управляющие.
Пустая ячейка рядом с кодом 32 на самом деле не пустая, это {\em пробел}.
Печать пробела сдвигала каретку вправо на одну позицию, не производя никакого видимого эффекта.
Для сдвига каретки влево использовался управляющий символ с кодом 8~--- backspace.

Сейчас нажатие клавиши Backspace стирает символ перед курсором, но на телетайпах он, конечно, оставался на бумаге.
Программисты тех лет изобретали трюки, позволявшие печатать, скажем, зачёркнутый текст.
Чтобы зачеркнуть слово PROGRAM, надо было напечатать буквы P, R, O, G, R, A, M, затем 7 символов BS (устоявшийся акроним для символа с кодом 8) и ещё 7 символов дефис (-), которые печатались поверх букв.

Получалось \sout{PROGRAM}.

Что ж, исследуем символы ASCII и узнаем, что можно с ними делать.

\section{Буквы, цифры}

\begin{Exercise}
  \Question
  Алина пишет программу, которая умеет распознавать числа в текстовых файлах, которые хранятся в кодировке ASCII.
  Ей нужна функция, которая умеет определять, является ли символ ASCII цифрой.
  Стандартная библиотека Rust работает с символами Unicode, поэтому Алине нужно написать свою функцию, работающую с символами ASCII.
\end{Exercise}

\subsection{ASCII и Unicode}

Во-первых, давайте в общих чертах разберёмся, чем символы ASCII отличаются от Unicode.
Первое важное отличие заключается в том, что символы ASCII представляются и хранятся одинаково, в виде одного-единственного байта.
В Rust их тип совпадает с типом для хранения байтов, а именно \code{u8} (беззнаковое 8-мибитовое число).

Работая с ASCII символами, мы можем указывать их код, например, 65, или сам симфол с префиксом \code{b}.
Коду 65 соответствует символ \code{b'A'}.

В Unicode символ Ⓐ (латинская заглавная A в круге) имеет десятичный код 9398.
То, как она хранится в памяти и на диске, зависит от способа кодирования.
Код символов Unicode принято указывать в шестнадцатиричном виде с префиксом \code{U+}.
Ⓐ имеет код \code{U+24B6}~--- это способ представления символа.

Способ хранения может быть разным.
В Rust одиночный символ Unicode хранится в формате UTF-32, то есть в виде 32-хбитного числа.

В стандартной библиотеке Rust есть метод \code{is\_ascii\_digit()}, но он работает только с символами Unicode.
Если мы оперируем байтами, нам придётся переводить их в символы Unicode перед тем, как вызвать стандартный метод.
Чтобы не делать этого, давайте напишем свой метод проверки.

В таблице ASCII цифры расположены подряд в кодовых позициях с 48-й (это \code{'0'}) по 57-ю (это \code{'9'}).
Это сильно упрощает реализацию.

\begin{lstlisting}[language=Rust]
pub fn is_digit(c: u8) -> bool {
  c >= 48 && c <= 57
}
\end{lstlisting}

Такой код сложно понимать, поскольку для этого надо знать (и помнить), что означают коды 48 и 57.
В Rust мы можем переписать его следующим образом.

\begin{lstlisting}[language=Rust]
pub fn is_digit(c: u8) -> bool {
  c >= b'0' && c <= b'9'
}
\end{lstlisting}

Похожим образом напишем функции, распознающие {\em маленькие} и {\em большие} буквы английского.

\begin{lstlisting}[language=Rust]
pub fn is_lower(c: u8) -> bool {
  c >= b'a' && c <= b'z'
}

pub fn is_upper(c: u8) -> bool {
  c >= b'A' && c <= b'Z'
}
\end{lstlisting}

Функция, распознающая буквы вне зависимости от регистра (от того, большие они или маленькие) уже сложнее.
Ей нужно проверять два несвязанных диапазона значений, поскольку в таблице ASCII между большими и маленькими буквами затесалось несколько символов.
Впрочем, мы можем воспользоваться тем, что уже написали функции \code{is\_lower()} и \code{is\_upper()} и свести задачу к их вызову.

\begin{lstlisting}[language=Rust]
pub fn is_letter(c: u8) -> bool {
  is_lower(c) || is_upper(c)
}
\end{lstlisting}

\subsection{Меняем регистр}

Английские буквы в таблице ASCII, что большие, что маленькие, расположены в алфавитном порядке без разрывов.
Это решение~--- очень логичное~--- упрощает большое количество практических задач.
Например, чтобы сортировать строки в {\em лексикографическом порядке}, достаточно обычного сравнения символов без дополнительных ухищрений.

Чтобы узнать код маленькой буквы \code{'x'} (120), надо прибавить 32 к коду большой буквы \code{'X'} (88).
Приведение к большим или маленьким буквам~--- частая операция, которая позволяет сортировать строки в алфавитном порядке без учёта регистра.
Простейшая функция, которая приводит большие буквы к маленьким, выглядит так.

\begin{lstlisting}[language=Rust]
pub fn to_lower(c: u32) -> u32 {
  c + 32
}
\end{lstlisting}

Однако, она работает только с большими буквами. Если вы передадите ей цифру или маленькую букву, то получите мусор.
Чтобы функция работала правильно, надо проверять, что мы действительно имеем дело с большой буквой.

\begin{lstlisting}[language=Rust]
pub fn to_lower(c: u32) -> u32 {
  if is_upper(c) {
    c + 32
  } else {
    c
  }
}
\end{lstlisting}

Этот код работает уже правильно, но читается всё ещё плохо.
Из кода неясно назначение константы 32.
Сделаем его очевидным.

\begin{lstlisting}[language=Rust]
pub fn to_lower(c: u32) -> u32 {
  if is_upper(c) {
    c + (b'a' - b'A')
  } else {
    c
  }
}
\end{lstlisting}

Выражение \code{b'a' - b'A'} можно трактовать, как {\em расстояние} между маленькими и большими буквами в таблице ASCII.

\subsection{Упражнения}

\begin{Exercise}
  \Question
  Напишите функцию \code{is\_control()}, которая распознаёт управляющие символы.
  К управляющим символом относятся символы с кодами от 0 до 31 включительно, а также символ с кодом 127.
\end{Exercise}
  
\begin{Exercise}
  \Question
  Напишите функцию \code{to\_upper()}, которая приводит маленькие буквы к большим.
\end{Exercise}

\subsection{Переводим строку в число}

Процессор легко оперирует числами — двубайтными, четырёхбайтными, восьмибайтными.
Однако в тексте программ числа записаны символами и перед вычислениями их надо перевести в доступную для компьютера форму.
Строку \code{"12345"} в число \code{12345}.

Этот процесс называют иногда {\em конвертацией}, иногда~--- {\em лексическим анализом} (parsing).
Также говорят, что это {\em приведение} типа.

В Rust это {\em анализ}, поскольку соответсвующий метод называются \code{parse<T>()}.
Он работает с Unicode-строками, а мы напишем версию для ASCII-строк.
В Rust ASCII-строка~--- это на самом деле массив байтов.
Мы можем в явном виде перечислить коды символов, либо можем записать строку с префиксом \code{b}.
\code{b"Bar"}~--- ASCII-строка, содержащая символы \code{b'B'}, \code{b'a'} и \code{b'r'}.

\subsection{Идея алгоритма}

Предоложим, мы конвертируем в число строку \code{"153"} и к настоящему моменту уже сконвертировали цифры 1 и 4.
Переменная, в которой мы {\em собираем} значение~--- {\em аккумулятор}~--- хранит число 15.

Если далее снова следует цифра, значит, речь идёт уже не о числе 15, а о числе 150 плюс эта самая цифра.
Мы должны умножить аккумулятор на 10 (как бы сдвинуть цифры на одну позицию влево) и прибавить найденную цирфу (как бы вписать её в пустую позицию справа).
Однако, код цифры \code{'3'}, в ASCII равен не 3, а 51. Чтобы получить 3, надо из \code{b'3'} вычесть код символа \code{b'0'}, то есть 48.

\begin{lstlisting}[language=Rust]
  // ...
  let mut accumulator: u32 = 0;
  let mut i = 0;

  while i < s.len() && is_digit(s[i]) {
    let next_digit = u32::from(s[i] - b'0');
    accumulator = 10 * accumulator + next_digit;

    i += 1;
  }
  // ...
\end{lstlisting}

Здесь мы предполагаем, что исходная строка с цифрами находится в переменной \code{s}.
У нас есть индексная переменная \code{i}, с помощью которой мы можем обратиться к каждому символу, начиная с самого первого (имеет индекс \code{0}), до самого последнего (индекс \code{s.len() - 1}).
Из-за явного преобразования типов в Rust, мы не можем непосредственно прибавить значение типа \code{u8} к значению типа \code{u32}, поэтому нам требуется метод \code{u32::from()}.

В самом начале аккумулятор равен 0.
Цикл устроен так, что когда будет прочитана первая цифра, например, \code{'1'}, 0 будет умножен на 10 и это всегда даст результат 0.
Мы можем обрабатывать первую цифру также, как и все остальные цифры, не реализуя {\em особый случай}.

Какой результат должна возвращать функция анализа?
Если в строке совсем нет цифр, то и результата преобразования тоже нет.
Подходящим типом для выражения этой идеи является \code{Option<u32>}.
Таким образом, функция целиком приобретает такой вид.

\begin{lstlisting}[language=Rust]
pub fn parse_u32(s: &[u8]) -> Option<u32> {
  if s.len() == 0 || !is_digit(s[0]) {
    return None;
  }

  let mut accumulator: u32 = 0;
  let mut i = 0;

  while i < s.len() && is_digit(s[i]) {
    let next_digit = u32::from(s[i] - b'0');
    accumulator = 10 * accumulator + next_digit;

    i += 1;
  }

  Some(accumulator)
}
\end{lstlisting}

На вход функция получает массив байт, по сути~--- строку символов ASCII.
Если массив пуст, или начинается не с цифры, функция возвращает \code{None}~--- пустой результат.
Если массив не пуст и в нём есть хотя бы одна цифра, функция {\em перебирает} все цифры, одновременно пересчитывая значение в аккумуляторе.
Когда цикл завершается, в аккумуляторе находится искомый результат.
Мы возвращаем \code{Some(accumulator)}, потому что результат нашей функции~--- {\em опциональный} тип, которой должен либо не содержать ничего (\code{None}), либо содержать что-то (\code{Some}).

\subsection{Переполнение}

Функция работает корректно, пока мы не попытаемся сконвертировать достаточно большое число, например, 5\,000\,000\,000.
Тогда программа остановися с сообщением об ошибке.

\begin{lstlisting}
thread 'main' panicked at src\ascii\mod.rs:45:23:
attempt to multiply with overflow
\end{lstlisting}

Тип \code{u32} хранит 32-хбитные числа без знака.
Максимальное возможное значение \code{u32::MAX} равно 4\,294\,967\,295 или $2^32-1$.
Если число в строке превышает \code{u32::MAX}, на очередном шаге заполнения аккумулятора происходит {\em переполнение} (overflow).
Чтобы справиться с этой ошибкой, мы должны «читать» из входной строки цифры, пока они помещаются в \code{u32::MAX}.
Если при добавлении цифры происходит переполнение, мы завершаем разбор строки и возвращаем число, которое успели прочитать к настоящему моменту.

У нас для {\em накопления} используется составная формула.

\begin{lstlisting}[language=Rust]
accumulator = 10 * accumulator + next_digit.
\end{lstlisting}

Проверку придётся делать в два этапа. Давайте вначале убедиться, что прибавление цифры не приведёт к переполнению.

\begin{lstlisting}[language=Rust]
if 10 * accumulator + next_digit > u32::MAX {
  return Some(accumulator);
}
\end{lstlisting}

К сожалению, код в таком виде не работает, потому что условие всегда будет {\em ложным}.
Числа, хранящиеся в \code{u32} не могут быть больше \code{u32::MAX}.
Выражение в левой части всё равно может привести к переполнению, а, значит, и к остановке программы.
Чтобы избавиться от переполнения, перенесём слагаемое \code{next\_digit} в правую часть.

\begin{lstlisting}[language=Rust]
if 10 * accumulator > u32::MAX - next_digit {
  return Some(accumulator);
}
\end{lstlisting}

Точно также, мы должны убедиться, что \code{10 * accumulator} меньше, чем \code{u32::MAX}.
Как и в случае со сложением, нам надо перенести 10 из левой части в правую.

\begin{lstlisting}[language=Rust]
if accumulator > u32::MAX / 10
|| 10 * accumulator > u32::MAX - next_digit {
  return Some(accumulator);
}
\end{lstlisting}

Полный код безопасного преобразования выглядит так.

\begin{lstlisting}[language=Rust]
pub fn parse_u32(s: &[u8]) -> Option<u32> {
  if s.len() == 0 || !is_digit(s[0]) {
    return None;
  }

  let mut accumulator: u32 = 0;
  let mut i = 0;

  while i < s.len() && is_digit(s[i]) {
    let next_digit = u32::from(s[i] - b'0');
    if accumulator > u32::MAX / 10
    || 10 * accumulator > u32::MAX - next_digit {
      return Some(accumulator);
    }

    accumulator = 10 * accumulator + next_digit;
        
    i += 1;
  }

  Some(accumulator)
}
\end{lstlisting}

В реальном программировании часто приходится проверять граничные условия, что усложняет программу, но является необходимой частью кода.
Функция \code{parse\_u32()} при конвертации строки \code{"4294967296"}, читает не 10 символов, а 9 и возвращает \code{Some(429496729)}.
4\,294\,967\,296 на единицу больше \code{u32::MAX} и приводит к переполнению.

\section{Шифр Цезаря}

Говорят, что Цезарь придумал отсроумный способ шифрования, который позволял быстро кодировать и декодировать латинский текст.
Компьютеров во времена Цезаря не было, поэтому кодирование и декодирование осуществлялись в уме.
Этот метод шифрования симметричный, то есть для кодирования и декодирования используется один и тот же ключ.
Для шифра Цезаря ключ~--- это натуральное число, скажем, 5.

A B C D E F G H I J K L N M O P Q R S T U V W X Y Z

Для того, чтобы зашифровать букву, мы должны взять пятую букву справа от неё.
Если мы дошли до конца алфавита, просто продолжаем считать с начала.
Пятая буква справа от A~--- это F, пятая буква справа от Q~--- это V, и пятая буква от X~--- C.
Таким образом, строка LOREM кодируется в строку QTWJR.

Декодировашие осуществляется похожим образом, только вместо пятой буквы справа ищем пятую букву слева, а, если доходим до начала алфавита, продолжаем считать с конца.

\begin{Exercise}
  \Question
  Настя реализует шифр Цезаря. Ей нужно написать фунукцию, которая шифрует один ASCII-символ.
  Функция получает на вход букву и ключ~--- положительное число типа \code{u8}.
  Функция шифрует большие и меленькие буквы независимо~--- строка \code{b"LOREM"} с ключом 5 превращается в \code{b"QTWJR"}, а \code{b"lorem"}~--- в \code{b"qtwjr"}.
  Помогите Насте реализовать шифрование.
\end{Exercise}

\subsection{Проектирование алгоритма}

Тексты состоят из больших букв, маленьких букв и других символов, таких как пробелы и знаки препинания.
Наша функция шифрования, судя по описанию, должна отдельно шифровать большие буквы и маленькие буквы, а все прочие символы оставлять неизменными.
Значит, у нас есть три варианта, которые программа должна уметь обрабатывать.

\begin{lstlisting}[language=Rust]
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
  if is_lower(c) {
    // ...
  } else if is_upper(c) {
    // ...
  } else {
    c
  }
}
\end{lstlisting}

{\em Сдвиг}~--- это, фактически, прибавление ключа к коду символа. Символ \code{b'L'} имеет код 76.
Если прибавить 5, получим 81, а это код символа \code{b'Q'}.

Для того, чтобы безопасно переходить границу алфавита, мы будем использовать {\em модульную арифметику}.
В арифметике по модулю $N$, значения могут находиться только в диапазоне от $0$ до $N - 1$.
Если в процессе вычислений мы получаем число вне этого интервала, то используем в качестве результата {\em остаток от деления} числа на $N$.
В английском алфавите 26 букв. Для вычислений нам потребуется остаток от деления на 26, который может принимать значения от 0 до 25.

Пронумеруем буквы алфавита. A получит номер 0, B~--- номер 1, С~--- 2 и так далее вплоть до Z, которая получит номер 25.
Предположим, мы хотим вычислить пятую букву справа от X. X имеет номер 23, прибавляем 5 и получаем 28.
Остаток от деления 28 на 26 даёт 2, и это номер символа C.

Чтобы реализовать этот алгоритм, нам надо перейти от кодов ASCII к нашей внутренней нумерации, выполнить преобразование, а затем преобразовать внутренний номер (от 0 до 25) обратно в код символа.
Первое преобразование мы сделаем, вычтя из кода буквы код первой буквы алфавита, а имеенно A: \code{c - b'A'}.

Затем мы должны прибавить ключ.
Если мы вышли за правую границу (за букву Z), то должны применить модульную арифметику.

\begin{lstlisting}[language=Rust]
if c - b'A' + key > 25 {
  // ...
}
\end{lstlisting}

Но, оказывается, это слишком сложный код для данной операции.
Если мы не вышли за правую границу, мы точно также можем использовать модульную арифметику (вычислять остаток), потому что если результат меньше модуля, то он останется тем же самым.

\begin{lstlisting}[language=Rust]
(c - b'A' + key) % 26
\end{lstlisting}

Мы получили внутренний номер буквы, то есть число от 0 до 25. Чтобы превратить его в код ASCII, надо прибавить к нему код символа A.

\begin{lstlisting}[language=Rust]
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
  if is_lower(c) {
    (c - b'a' + key) % 26 + b'a'
  } else if is_upper(c) {
    (c - b'A' + key) % 26 + b'A'
  } else {
    c
  }
}
\end{lstlisting}

\subsection{Работаем над стилем}

Этот код довольно прозрачен.
Модульная арифметика встречается часто, поэтому программисты распознают её практически не лету.
Мы видим оператор \code{\%}~--- остаток от деления, и понимаем, что речь идёт об арифметике по модулю 26.
Большинство из нас опознают 26 как {\em размер английского алфавита} или {\em количество букв в английском алфавите}.

Но эту идею можно выразить явно:

\begin{lstlisting}[language=Rust]
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
  const LETTER_COUNT: u8 = b'Z' - b'A' + 1;

  if is_lower(c) {
    (c - b'a' + key) % LETTER_COUNT + b'a'
  } else if is_upper(c) {
    (c - b'A' + key) % LETTER_COUNT + b'A'
  } else {
    c
  }
}
\end{lstlisting}

Возможно у вас возникает вопрос, почему количество букв, это код символа Z минут код символа A {\em плюс единица}.
Ответ заключается в том, что, если бы мы не прибавили единицу, мы получили бы известную ошибку, у которой даже есть название — {\em off-by-one error} или {\em ошибка неучтённой единицы}.
Она часто встречается в программах, даже не смотря на то, что считается одной из самых известных, то есть программисты должны были бы её опознавать предотвращать.

Так что же такое ошибка неучтённой единицы?
Предположим, мы едем по трассе, где расположены километровые столбы.
Мы видим столб 173, затем через некоторое время столб 205, и хотим узнать, сколько километров мы проехали.
Правильный ответ $205 - 173$ или 32 километра.

Затем мы хотим узнать, сколько столбов {\em между} столбами 173 и 205?
Интуитивно снова хочется ответить 32, но на самом деле нет.
Сколько столбов между 173 и 175? Всего один~--- с номером 174.
Это на единицу {\em меньше}, чем $175 - 173$.
Правильный ответ на вопрос «сколько столбов между 173 и 205» равен $(205 - 173) - 1$ или 31.

Следующий вопрос: сколько всего столбов от столба 173 до столба 205?
Интуитивный ответ такой же, как и в прошлом случае: 32.
Но сколько всего столбов от столба 173 до столба 175? Три~--- с номерами 173, 174 и 175.
Это на единицу {\em больше}, чем $175 - 173$.
Правильный ответ на вопрос «сколько столбов от столба 173 до столба 205» составляет $(205 - 173) + 1$ или 33.

Программисты должны опознавать оба случая и прибавлять, либо вычитать единицу, когда надо.
Возвращаемся к английскому алфавиту. Наш вопрос звучит так: «сколько всего букв от буквы A до буквы Z»?
И, как мы только что выяснили, чтобы ответить на этот вопрос правильно, надо прибавить единицу к разнице `b'Z' - b'A'`.

\subsection{Работаем над ошибками}

Что ж, код идеален за одним исключением. В качестве ключа мы можем получить достаточно большое число, например, 250.
Кодируя букву `b'Z'` мы сначала получим её номер~--- то есть 25, потом прибавим к ней ключ, получив 275, и затем найдём остаток от деления на 26~-- то есть 15.
Но 275 больше, чем 255, а 255~--- максимальное значение, которое можно хранить в переменной типа \code{u8}.
При вычислении мы получим ошибку переполнения, хотя, по сути, никакой ошибки нет.

Что можно сделать?
Вариант номер один: использовать в процессе вычислений числа типа `u16` или `u32`.
Вариант номер два: обратить внимание на природу задачи.
В нашем случае, поскольку мы используем модульную арифметику, актуальные значения ключа — от 0 до 25.
Почему?

Представим, ключ равен 2. Имея букву в номером \code{n}, мы можем вычислит номер зашифрованной буквы по формуле \code{(n + 2) \% 26}.
Если мы используем ключ 28 (то есть $2 + 26$), номер зашифрованной буквы будет равен \code{(n + 28) \% 26}.
Но, поскольку раница $28-2$ делится на 26 без остатка, по правилам модульной арифметики, результат будет один и тот же.
То же самое справделиво и для ключей $2 + 26 + 26$, $2 + 26 + 26 + 26$ и так далее.
Так что мы можем в начале функции «урезать» ключ, вычислив отстаток от его деления на 26.

\begin{lstlisting}[language=Rust]
pub fn caesar_encode_char(c: u8, key: u8) -> u8 {
  const LETTER_COUNT: u8 = b'Z' - b'A' + 1;
  let key = key % LETTER_COUNT;

  if is_lower(c) {
    (c - b'a' + key) % LETTER_COUNT + b'a'
  } else if is_upper(c) {
    (c - b'A' + key) % LETTER_COUNT + b'A'
  } else {
    c
  }
}
\end{lstlisting}

\begin{Exercise}
  \Question
  Реализуйте обратную функцию декодирования, которая получает на вход букву и ключ и возвращает декодированную большую или маленькую букву, или тот же самый символ, если это буква.
\end{Exercise}
